# CMake Build System

## PyCMake Helper Script

**Location**: `/Engine/Scripts/pycmake/` (external Python package)  
**Runtime Script**: `/Engine/Source/Runtime/Runtime_cmake.py`

### Overview

PyCMake is a custom Python-based build system wrapper that automatically generates CMake projects. It provides a higher-level abstraction for build configuration, inspired by Unreal Engine's build system but simplified for this project.

### Key Components

#### 1. VcpkgContext
Manages dependency configuration through vcpkg:
```python
vcpkg_ctx_runtime = VcpkgContext(
    vcpkg_root_path='../Dependency/vcpkg',
    vcpkg_config=VcpkgConfigModel(
        name='Runtime',
        version='0.2.1',
        dependencies=[
            "glfw3", "glm", "dylib", "vulkan-memory-allocator",
            "glslang", "assimp", "bullet3"
        ]
    )
)
```

#### 2. FindPackage & FetchContent
Two methods for dependency management:
- **FindPackage**: For system/vcpkg-installed packages (e.g., Vulkan, glfw3, glm)
- **FetchContent**: For GitHub-based dependencies (e.g., nvrhi)

#### 3. Module Definition
Modules are defined as Python classes inheriting from `BaseModule`:
```python
class RuntimeModule(BaseModule):
    def __init__(self):
        super().__init__(
            module=ModuleTargetModel(
                target='Runtime',
                type=ModuleEnum.STATIC,
                source_files=PyCMakeUtil.glob([...]),
                unity_build=True,
                unity_build_exclusion_patterns=['*VulkanLoader*']
            ),
            fetch_packages=[nvrhi],
            find_packages=[vulkan, glfw3, glm, ...]
        )
```

### Global Configuration Options

```python
bThreadSanitizer = False          # Thread sanitizer (low performance)
bBuildShared = False              # Shared library build (not recommended on Linux)
bVulkanNoPrototype = True         # Dynamic Vulkan API loading
bVulkanSDKOverridePath = True     # Use specific Vulkan SDK version
```

### Compile Options

The project uses strict clang warnings:
```python
target_compile_options(Runtime PUBLIC 
    '$<$<COMPILE_LANGUAGE:CXX>:-Wall -Wextra -pedantic -Werror -Wunused-variable -Wconversion -Weverything>',
    '$<$<COMPILE_LANGUAGE:CXX>:-Wno-padded -Wno-gnu-zero-variadic-macro-arguments ...>'
)
```

### Usage Workflow

1. Modify `Runtime_cmake.py` to change build configuration
2. Run `./GenerateCMakeProjects.sh` to generate CMakeLists.txt
3. Use `./Build.sh` to build the project

**Note**: The generated `CMakeLists.txt` is automatic - DO NOT edit manually unless absolutely necessary.

---

## Vcpkg

**Location**: `/Engine/Source/Dependency/vcpkg`  
**Documentation**: `/Engine/Source/Dependency/README.md`

### Overview

The project uses a **forked version of vcpkg** (https://github.com/yhyu13/vcpkg) to manage C++ dependencies. This fork is based on the official Microsoft vcpkg but customized for project-specific needs.

### Dependency Management

#### Installed Packages (via vcpkg)
- **Graphics**: glfw3, glm, VulkanMemoryAllocator, glslang, assimp, bullet3
- **Common**: dylib, spdlog, mimalloc, magic_enum, Boost
- **Security**: botan3, zstd
- **Serialization**: rapidjson, nlohmann_json, protobuf, grpc
- **Networking**: curl
- **Observability**: opentelemetry

#### vcpkg.json
Located at `/Engine/Source/Runtime/vcpkg.json`, auto-generated by PyCMake.

### How to Upgrade Vcpkg

See `/Engine/Source/Dependency/README.md` for detailed upgrade procedure:

1. Update the fork's `latest` branch to match microsoft/vcpkg
2. Backup current vcpkg: `cp -r vcpkg vcpkg_old`
3. Create upgrade branch: `git checkout -b hlvm_upgrade`
4. Rebase: `git pull --rebase origin latest`
5. Clean and rebuild all targets
6. Fall back to `hlvm` branch if issues occur

### Best Practices

- Always use vcpkg for third-party dependencies (no manual downloads)
- Keep vcpkg submodule updated but stable
- Use `bBuildShared=False` on Linux (shared libs have compatibility issues)

---

## Result (Generated CMakeLists.txt)

**Location**: `/Engine/Source/Runtime/CMakeLists.txt`

### Overview

This file is **100% auto-generated** by PyCMake from `Runtime_cmake.py`. It should NOT be manually edited.

### Structure

1. **Functions Section**: Helper functions for unity build, test execution
2. **Project Setup**: CMake minimum version, project declaration
3. **Subdirectories**: Common module included first
4. **Global Sets**: Compiler, linker, output directory configurations
5. **Module Definitions**: Static/shared library targets
6. **Fetch Packages**: GitHub content fetching (e.g., nvrhi)
7. **Find Packages**: System/vcpkg package discovery
8. **Test Executables**: Individual test targets with CTest integration

### Key Generated Configurations

```cmake
# C++ Standard
set(CMAKE_CXX_STANDARD 23)

# Linker
set(CMAKE_LINKER_TYPE GOLD)
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)

# Output Directories
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/Binary/${CMAKE_BUILD_TYPE})

# Build Definitions
add_compile_definitions(
    $<$<CONFIG:Debug>:HLVM_BUILD_DEBUG=1>
    $<$<CONFIG:RelWithDebInfo>:HLVM_BUILD_DEVELOPMENT=1>
    $<$<CONFIG:Release>:HLVM_BUILD_RELEASE=1>
)
```

### Unity Build

The project uses CMake unity build for faster compilation:
```cmake
set_target_properties(Runtime PROPERTIES UNITY_BUILD ON)
# Exclusions for files that can't be unity-built (e.g., VulkanLoader)
set_property(SOURCE VulkanLoader.cpp PROPERTY SKIP_UNITY_BUILD_INCLUSION ON)
```

---

# Build & Test

**Script**: `/Engine/Source/Runtime/Build.sh`

### Overview

Comprehensive bash script for building, testing, and profiling the project. Supports multiple build configurations, parallel execution, and performance analysis with gperftools.

### Usage

```bash
./Build.sh [OPTIONS]
```

### Available Options

| Option | Description | Example |
|--------|-------------|---------|
| `--Config=<type>` | Build configuration | `--Config=Debug` |
| `--Target=<name>` | Specific target to build/test | `--Target=TestParallel` |
| `--Test` | Run CTest after build | `--Test` |
| `--Clean` | Clean build directory before build | `--Clean` |
| `--Rebuild` | Clean and rebuild | `--Rebuild` |
| `--Verbose` | Enable verbose CMake output | `--Verbose` |
| `--GraphViz` | Generate dependency graph (build.dot) | `--GraphViz` |
| `--GPerf` | Enable gperftools profiling | `--GPerf` |
| `--Jobs=<N>` | Number of parallel jobs | `--Jobs=8` |
| `--TestRepeatNum=<N>` | Number of test repetitions | `--TestRepeatNum=2` |

### Build Configurations

The script builds all three configurations by default:
- **Debug**: Full debugging symbols, no optimization
- **RelWithDebInfo**: Release with debug info (recommended for development)
- **Release**: Full optimization, minimal debug info

### Test Execution

Tests are run in parallel (max 8 concurrent) with automatic log capture:
```bash
./Build.sh --Test --TestRepeatNum=2
```

Test logs are saved to: `Testing/build_test_<config>_<testname>.log`

### Performance Profiling

With `--GPerf` flag:
```bash
./Build.sh --Config=RelWithDebInfo --GPerf --Target=TestParallel
```

Output includes:
- CPU time per function
- Call graph analysis
- Memory allocation hotspots

### Log Files

Build logs are generated in the script directory:
- `build_<config>.log`: Standard build output
- `rebuild_<config>.log`: Rebuild output
- `clean_<config>.log`: Clean output
- `Testing/`: Test and profiling logs

### Example Commands

```bash
# Full rebuild with tests
./Build.sh --Rebuild --Test

# Debug single test
./Build.sh --Config=Debug --Target=TestParallel --Test

# Performance analysis
./Build.sh --Config=RelWithDebInfo --GPerf --Target=TestMemory
```

---

# Repo Structure

### Directory Layout

```
HLVM-Engine/
├── Engine/
│   ├── Scripts/
│   │   ├── pycmake/          # PyCMake Python package
│   │   └── Setup.sh          # Environment setup
│   └── Source/
│       ├── Common/           # Shared utilities (headers + sources)
│       │   ├── Public/       # Public headers
│       │   ├── Private/      # Implementation files
│       │   └── Test/         # Common test utilities
│       └── Runtime/          # Engine runtime module
│           ├── Public/       # RHI, Window, etc.
│           ├── Private/      # Implementation
│           └── Test/         # Runtime tests
├── Binary/                   # Build outputs (auto-generated)
├── Build/                    # CMake build directories (auto-generated)
└── DOC_Coding_Style.md       # This file
```

### Public/Private Pattern

**Inspired by Unreal Engine**, the project uses a strict Public/Private separation:

#### Public/ (Headers)
- Interface definitions
- Template implementations (`.tpp`)
- Export macros
- **Accessible by**: All modules that link against this module

#### Private/ (Sources)
- Implementation files (`.cpp`)
- Internal helpers
- **Accessible by**: Only the module itself

**Example**:
```
Engine/Source/Common/
├── Public/
│   ├── Core/
│   │   ├── String.h          # FString class declaration
│   │   ├── Log.h             # Logging macros
│   │   └── Mallocator/
│   │       └── MiMallocator.h
│   └── Platform/
│       └── FileSystem/
└── Private/
    └── Core/
        └── Mallocator/
            └── Mallocator.cpp # Global new/delete override
```

### Module Organization

Each module (Common, Runtime) is a self-contained CMake target with:
- Its own Public/Private directories
- Independent test suite
- Separate PCH (Precompiled Header)

**Include Paths**:
```cpp
// From Runtime module including Common
#include "Core/String.h"        // Resolves to Common/Public/Core/String.h
#include "Platform/FileSystem.h" // Resolves to Common/Public/Platform/FileSystem.h
```

---

# CPP Standard

### Primary Standard: **C++20** (with C++23 extensions)

The project primarily targets **C++20**, but uses C++23 where beneficial and compiler-supported.

### CMake Configuration

```cmake
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_C_STANDARD 23)
```

### Key C++20 Features Used

1. **Concepts**
   ```cpp
   template <CLockable T>
   class TAtomicLockGuard { ... };
   ```

2. **Modules** (limited use, mostly for testing)

3. **Coroutines** (experimental, in WorkStealThreadPool)

4. **Ranges** (minimal use, preference for traditional loops)

5. **`std::span`**
   ```cpp
   using FByteBuffer = std::span<TBYTE>;
   using FConstByteBuffer = std::span<const TBYTE>;
   ```

### Compiler Flags

```bash
-Wall -Wextra -pedantic -Werror
-Wconversion -Weverything
-Wno-padded -Wno-gnu-zero-variadic-macro-arguments
-Wno-reserved-identifier -Wno-exit-time-destructors
-Wno-global-constructors -Wno-c++98-compat-pedantic
```

### Restrictions

- **NO** `auto` in critical performance paths (explicit types preferred)
- **NO** exceptions (custom assertion system instead)
- **NO** RTTI (disabled for performance)
- **Minimal** dynamic allocation in hot paths (use stack allocators)

---

# Boost Library Usage Scope

**Boost** is used selectively for specific functionality where standard library alternatives are insufficient or less performant.

### Approved Usage Areas

#### 1. Container Extensions (`boost::container`)

**File**: `/Engine/Source/Common/Public/Core/Container/ContainerDefinition.h`

```cpp
#include <boost/container/vector.hpp>
#include <boost/container/small_vector.hpp>
#include <boost/container/static_vector.hpp>
#include <boost/circular_buffer.hpp>
```

**Types**:
- `TSmallVector<T, N>`: Stack-allocated vector with heap fallback
- `TSmallVector32<T>`: 32-element small vector
- `TSmallVector64<T>`: 64-element small vector
- `TRingBuffer<T>`: Circular buffer

**Rationale**: Better performance than `std::vector` for small sizes, no dynamic allocation for stack vectors.

#### 2. Filesystem (`boost::filesystem`)

**File**: `/Engine/Source/Common/Public/Platform/FileSystem/Boost/BoostMapFileHandle.h`

```cpp
#include <boost/filesystem.hpp>
```

**Usage**:
- Memory-mapped file handling
- Cross-platform path manipulation
- Directory iteration

**Rationale**: More mature than `std::filesystem` for memory mapping, better Linux support.

#### 3. Fibers (`boost::fibers`)

**File**: `/Engine/Source/Common/Public/Core/Parallel/Async/WorkStealFiberPool.h`

```cpp
#include <boost/fiber/all.hpp>
```

**Usage**: User-space threading for fine-grained parallelism

**Note**: Currently experimental, has stability issues with work stealing.

### NOT Used

- Boost.Asio (custom async system preferred)
- Boost.Serialization (using rapidjson/protobuf instead)
- Boost.Test (using CTest instead)

### Migration Policy

New code should prefer:
1. Standard library equivalents when available
2. Custom implementations for performance-critical paths
3. Boost only when no better alternative exists

---

# Common

**Location**: `/Engine/Source/Common/`

The Common module provides foundational utilities used across all engine modules. It's designed to be self-contained with minimal external dependencies.

## Memory

### Mallocator System

**File**: `/Engine/Source/Common/Public/Core/Mallocator/MiMallocator.h`

The project implements a **pluggable memory allocator system** inspired by Unreal Engine's FMalloc interface.

#### Architecture

```cpp
class IMallocator {
    virtual void* Malloc(size_t size) = 0;
    virtual void Free(void* ptr) = 0;
    // ... other allocation methods
};
```

#### Implementations

1. **FMiMallocator** (Default)
   - Wrapper around Microsoft's mimalloc
   - Thread-local by default
   - Supports custom heaps
   
   ```cpp
   struct FMiMallocatorContext {
       bool bNewHeap{false};
       BIT_FLAG(bDestory){false};
   };
   
   HLVM_THREAD_LOCAL_VAR FMiMallocator GMiMallocatorTLS{};
   ```

2. **FStackAllocator**
   - 2-3x faster than mimalloc for stack-like allocation patterns
   - Used for temporary allocations in critical paths

3. **VMMallocator** (WIP)
   - Virtual memory arena-based allocator
   - Thread-local and lock-free design
   - Components:
     - `VMArena`: Manages virtual memory regions
     - `VMHeap`: Large block allocation within arena
     - `SmallBinnedMallocator`: Fast lock-free small allocations

#### Usage Pattern

```cpp
// Swap allocator temporarily
{
    SwapMallocator(&TempAllocator);
    // Allocations use TempAllocator
} // Automatically restores previous allocator
```

#### Global Override

The project overrides global `new` and `delete` to use the custom allocator system:
```cpp
// In Mallocator.cpp
void* operator new(size_t size) {
    return GMallocator->Malloc(size);
}
```

---

## Types

**File**: `/Engine/Source/Common/Public/Definition/TypeDefinition.h`

### Custom Type Aliases

The project defines fixed-width type aliases for portability and clarity:

```cpp
// Unsigned integers
#define TBYTE  std::byte
#define TUINT8 std::uint8_t
#define TUINT16 std::uint16_t
#define TUINT32 std::uint32_t
#define TUINT64 std::uint64_t
#define TUINT  TUINT64
#define TSIZE  TUINT64

// Signed integers
#define TINT8  std::int8_t
#define TINT16 std::int16_t
#define TINT32 std::int32_t
#define TINT64 std::int64_t
#define TINT   TINT64

// Floating point
#define TFP32  std::float_t
#define TFP64  std::double_t
#define TFLOAT TFP64  // Note: double precision by default
#define TDOUBLE TFP64

// Time
#define TTimePoint std::chrono::steady_clock::time_point
```

### Rationale

- **Consistency**: All engine code uses T-prefixed types
- **Portability**: Explicit width across platforms
- **Clarity**: `TSIZE` vs `size_t` makes engine types distinct
- **Double Precision**: `TFLOAT` is double precision by default (unlike typical float)

---

## FString

**File**: `/Engine/Source/Common/Public/Core/String.h`

### Overview

Custom string class inspired by Unreal Engine's FString, providing a unified string interface across the engine.

### Implementation

```cpp
class FString final : public std::basic_string<TCHAR>
{
public:
    FString() = default;
    FString(const char* str);
    FString(const TCHAR* str);
    FString(const std::string& str);
    
    // Conversion operators
    operator const TCHAR*() const;
    operator const char*() const;
    const char* ToCharCStr() const;
    
    // Formatting
    template <typename... Args>
    static FString Format(const TCHAR* _format, Args&&... args);
    
    // Join
    template <typename VecType, typename PredType>
    static FString Join(const VecType& Vec, const PredType& func, const TCHAR* splitter = TXT(",\n"));
};
```

### Key Features

1. **TCHAR Compatibility**
   - `TCHAR` is `char8_t` (UTF-8)
   - Compatible with `char` via reinterpret_cast
   - Seamless conversion to/from `std::string`

2. **TXT Macro**
   ```cpp
   FString str = TXT("Hello World");  // UTF-8 string literal
   ```

3. **Format Function**
   ```cpp
   FString msg = FString::Format(TXT("Value: {}"), 42);
   FString named = FString::Format(TXT("Name: {0}, Age: {1}"), "Alice", 30);
   ```

4. **Hash Support**
   ```cpp
   namespace std {
       template <>
       struct hash<FString> {
           size_t operator()(const FString& str) const;
       };
   }
   ```

### Related Types

- **FStdString**: Wrapper around `std::basic_string<char>` for interop
- **TCharArray<N>**: Stack-allocated fixed-size string (for error handling where allocation is prohibited)

### Best Practices

- Use `FString` for all engine strings
- Use `TCharArray` for critical error messages (no allocation)
- Avoid `std::string` in engine code (use only for STL interop)

---

## Logging Macro

**File**: `/Engine/Source/Common/Public/Core/Log.h`

### Overview

UE5-inspired logging system with compile-time log level elimination, spdlog backend, and async/sync flushing.

### Architecture

```
FLogCategory → FLogContext → FLogDevice → FLogRedirector
     ↓              ↓             ↓              ↓
  LogTemp      File/Line     Console      Singleton Manager
```

### Log Categories

```cpp
// Declare a log category (default: trace level in Debug, info in Release)
DECLARE_LOG_CATEGORY(LogTemp)

// Declare with specific minimum level
DELCARE_LOG_CATEGORY2(LogRenderer, warning)
```

### Logging Macros

```cpp
// Basic logging
HLVM_LOG(LogTemp, info, TXT("Message"));
HLVM_LOG(LogTemp, error, TXT("Error: {}"), error_code);

// Conditional logging
HLVM_CLOG(condition, LogTemp, warning, TXT("Warning: {}"), msg);

// Conditional with fallback to fatal
HLVM_CLOG_ELSE_FATAL(condition, LogTemp, info, TXT("Expected: {}"), value);
```

### Log Levels

```cpp
spdlog::level::trace    // Most verbose
spdlog::level::debug
spdlog::level::info
spdlog::level::warning
spdlog::level::error
spdlog::level::critical
spdlog::level::off
```

### Log Devices

1. **FSpdlogConsoleDevice** (Default)
   - Async logger for trace/debug/info (non-blocking)
   - Sync logger for warning/error/critical (immediate flush)
   
   ```cpp
   class FSpdlogConsoleDevice : public FLogDevice {
       std::shared_ptr<spdlog::logger> AsyncLogger;
       std::shared_ptr<spdlog::logger> ImmediateLogger;
   };
   ```

2. **File Sink** (Rotating)
   - Configurable max file size
   - Automatic rotation

### Message Format

```
T[{thread_id}] Category:[file:line] message
Example: T[0x7f8a] LogTemp:[Main.cpp:42] Value: 42
```

### Performance Features

- **Compile-time elimination**: Logs below category's minimum level are compiled out
- **Async flushing**: trace/debug/info logs don't block
- **Sync flushing**: warning/error/critical logs are immediately visible
- **Thread ID tracking**: Each log includes hex thread ID

### Creating New Log Categories

```cpp
// In your module's header
DECLARE_LOG_CATEGORY(LogMyModule)

// In your code
HLVM_LOG(LogMyModule, debug, TXT("Debug info: {}"), value);
```

---

## CVar

**File**: `/Engine/Source/Common/Public/Utility/CVar/CVarMacros.h`  
**Documentation**: `/Engine/Source/Common/Public/Utility/CVar/README.md`

### Overview

UE5-inspired console variable system with INI file persistence, runtime modification, and console command interface.

### Creating CVars

```cpp
#include "Utility/CVar/CVarMacros.h"

// Boolean CVar
AUTO_CVAR_BOOL(r_VSync, true, "Enable vertical sync", EConsoleVariableFlags::Saved)

// Integer CVar
AUTO_CVAR_INT(r_MaxAnisotropy, 8, "Max anisotropic filtering", EConsoleVariableFlags::Saved)

// Float CVar
AUTO_CVAR_FLOAT(r_ScreenPercentage, 100.0f, "Screen percentage", EConsoleVariableFlags::Saved)

// String CVar
AUTO_CVAR_STRING(g_GameName, "HLVM Engine", "Game name", EConsoleVariableFlags::Saved)

// Reference to external variable
bool g_bFeature = true;
AUTO_CVAR_REF_BOOL(r_Feature, g_bFeature, "Enable feature", EConsoleVariableFlags::Saved)
```

### CVar Flags

```cpp
enum EConsoleVariableFlags {
    None = 0,
    Cheat = 1,              // Disabled in shipping
    Saved = 2,              // Persisted to INI
    RequiresRestart = 4,    // Needs restart to apply
    ReadOnly = 8,           // Read-only after init
    Developer = 16,         // Developer-only
    Console = 32,           // Visible in console
    Archive = 64            // Archived but not saved
};
```

### Runtime Usage

```cpp
// Get value (implicit conversion)
if (CVar_r_VSync) { /* ... */ }
int32_t aniso = CVar_r_MaxAnisotropy;

// Set value
CVar_r_VSync.SetValue(false);
CVar_r_MaxAnisotropy.SetValue(16);

// Reset to default
CVar_r_VSync.ResetToDefault();

// Check if modified
if (CVar_r_VSync.IsModified()) { /* ... */ }
```

### Console Commands

```cpp
// Execute commands
ConsoleCommandManager::Get().ExecuteCommand("Set r_VSync 1");
ConsoleCommandManager::Get().ExecuteCommand("Get r_MaxAnisotropy");
ConsoleCommandManager::Get().ExecuteCommand("Dump r");
ConsoleCommandManager::Get().ExecuteCommand("Reset r_ScreenPercentage");
ConsoleCommandManager::Get().ExecuteCommand("Save Engine.ini");
ConsoleCommandManager::Get().ExecuteCommand("Load Config/Game.ini");
```

### Built-in Commands

| Command | Description |
|---------|-------------|
| `Set <name> <value>` | Set CVar value |
| `Get <name>` | Get current value |
| `Dump <prefix>` | List all CVars with prefix |
| `Reset <name>` | Reset to default |
| `Help <command>` | Show command help |
| `Save <filename>` | Save to INI file |
| `Load <filename>` | Load from INI file |

### INI File Format

```ini
[/Script/Engine.Renderer]
r.VSync=1
r.GBufferFormat=2
r.MaxAnisotropy=8

[/Script/Engine.Engine]
bUseOnScreenDebugMessages=True
FrameRateLimit=60
```

### Integration

```cpp
// Load all CVars from default INI files
GetCVarManager().LoadAllFromIni();

// Save modified CVars on shutdown
GetCVarManager().SaveAllToIni();
```

---

## Platform

**Location**: `/Engine/Source/Common/Public/Platform/`

### Overview

Platform abstraction layer providing cross-platform implementations for Linux and Windows. Uses a generic base + platform-specific override pattern.

### File Structure

```
Platform/
├── PlatformDefinition.h          # Platform detection macros
├── GenericPlatform.h             # Base interface
├── GenericPlatformAtomicPointer.h # CAS operations
├── GenericPlatformDebuggerUtil.h  # Debugger detection
├── GenericPlatformCrashDump.h    # Crash dump generation
├── GenericPlatformStackTrace.h   # Stack trace printing
├── GenericPlatformFile.h         # File operations
├── GenericPlatformThreadUtil.h   # Thread utilities
├── GenericPlatformMemory.h       # Memory operations
├── LinuxGNU/                     # Linux-specific implementations
└── Windows/                      # Windows-specific implementations
```

### Platform Detection

```cpp
#if defined(_WIN32) || defined(_WIN64)
    #define PLATFORM_WINDOWS 1
    #include "Platform/Windows/WindowsPlatform.h"
#elif defined(__linux__)
    #define PLATFORM_LINUX 1
    #include "Platform/LinuxGNU/LinuxPlatform.h"
#endif
```

### Key Abstractions

#### 1. Atomic Operations

**File**: `GenericPlatformAtomicPointer.h`

```cpp
// Compare-and-swap for pointers
template <typename T>
bool PlatformCAS(T** ptr, T* expected, T* desired);
```

#### 2. Debugger Detection

**File**: `GenericPlatformDebuggerUtil.h`

```cpp
bool IsDebuggerPresent();  // Uses ptrace on Linux, IsDebuggerPresent on Windows
```

#### 3. Stack Trace

**File**: `GenericPlatformStackTrace.h`

```cpp
void PrintStackTrace(int skip_frames = 0);  // Uses backward-cpp
```

#### 4. File Operations

**File**: `GenericPlatformFile.h`

```cpp
bool FileExists(const TCHAR* path);
bool ReadFile(const TCHAR* path, TVector<TBYTE>& out_data);
bool WriteFile(const TCHAR* path, const TVector<TBYTE>& data);
```

#### 5. Thread Utilities

**File**: `GenericPlatformThreadUtil.h`

```cpp
TUINT64 GetCurrentThreadId();  // Cached in TLS
void SetThreadName(const char* name);
void SetThreadAffinity(std::thread::native_handle_type handle, int cpu_id);
```

### Implementation Pattern

```cpp
// GenericPlatformDebuggerUtil.h
HLVM_NODISCARD HLVM_STATIC_FUNC bool IsDebuggerPresent();

// LinuxPlatformDebuggerUtil.cpp
bool LinuxPlatformDebuggerUtil::IsDebuggerPresent() {
    return ptrace(PTRACE_TRACEME, 0, nullptr, 0) < 0;
}

// WindowsPlatformDebuggerUtil.cpp
bool WindowsPlatformDebuggerUtil::IsDebuggerPresent() {
    return ::IsDebuggerPresent();
}
```

---

## File System

**Location**: `/Engine/Source/Common/Public/Platform/FileSystem/`

### Overview

File system abstraction with multiple backends: Boost for local files, custom packed format for game assets.

### Architecture

```
IFileHandle (Interface)
    ├── FBoostFileHandle (Local files via Boost)
    ├── FStdFileHandle (Local files via std::fstream)
    └── FPackedFileHandle (Packed container files)
```

### Boost Backend

**File**: `Boost/BoostMapFileHandle.h`

```cpp
class FBoostFileHandle : public IFileHandle {
public:
    FBoostFileHandle(const FPath& path, EFileMode mode);
    
    // Memory mapping
    void* Map(size_t offset, size_t size);
    void Unmap(void* ptr);
    
    // Standard operations
    size_t Read(void* buffer, size_t size);
    size_t Write(const void* buffer, size_t size);
    void Seek(size_t offset);
    size_t Tell();
    size_t Size();
};
```

**Features**:
- Memory-mapped file support
- Cross-platform path handling
- Standard C file mode compatibility

### Packed File System

For game asset packaging with token-based indexing.

#### Token File

**File**: `Packed/PackedToken.h`

Describes file structure in packed containers:
```cpp
struct FPackedTokenEntry {
    size_t PathHash;      // Hash of file path (not stored as string)
    size_t Offset;        // Offset in container
    size_t Size;          // Uncompressed size
    size_t CompressedSize; // Compressed size
    ECompressionType Compression;
};
```

**Debug Format**: JSON representation for human readability:
```json
{
  "entries": [
    { "path": "assets/texture.dds", "hash": 12345, "offset": 0, "size": 1048576 }
  ]
}
```

#### Container File

**File**: `Packed/PackedContainerFragment.h`

Tightly packed data files for efficient memory mapping:
- Minimal 4MB mapped regions per fragment
- Lazy loading of fragments
- Proxy access through token entries

### Path Handling

**File**: `Path.h`

```cpp
class FPath {
public:
    FPath(const FString& path);
    
    // Operations
    FPath GetParent() const;
    FString GetFilename() const;
    FString GetExtension() const;
    
    // Hash (cached for performance)
    size_t GetHash() const;
    
    // Conversion
    operator boost::filesystem::path() const;
};
```

**Features**:
- Internal `boost::filesystem::path` storage
- Cached hash for fast lookups
- Cross-platform path separators

### File Modes

```cpp
enum class EFileMode {
    Read = 0,
    Write = 1,
    ReadWrite = 2,
    Append = 3,
    Binary = 4,
    Text = 8,
    // Combinations: Read | Binary, Write | Text, etc.
};
```

### Usage Example

```cpp
// Open file
auto handle = FFileHandle::Open(FPath("data/config.json"), EFileMode::Read | EFileMode::Binary);

// Read entire file
TVector<TBYTE> data;
data.Resize(handle->Size());
handle->Read(data.GetData(), data.NumBytes());

// Memory mapping (for large files)
void* mapped = handle->Map(0, handle->Size());
// ... access mapped memory ...
handle->Unmap(mapped);
```

---

# Runtime

**Location**: `/Engine/Source/Runtime/`

The Runtime module contains engine subsystems that depend on Common. It's the primary module for engine functionality.

## Window

**Location**: `/Engine/Source/Runtime/Renderer/Window/`

### Overview

Window management abstraction using GLFW3 with Vulkan integration.

### Architecture

```
IWindow (Interface)
    └── FGLFW3Window (GLFW3 implementation)
        └── FVulkanWindow (Vulkan-specific extensions)
```

### GLFW3 Window

**File**: `GLFW3/GLFW3Window.h`

```cpp
class FGLFW3Window : public IWindow {
public:
    FGLFW3Window(const FWindowConfig& config);
    ~FGLFW3Window();
    
    // Lifecycle
    void Show();
    void Hide();
    bool ShouldClose() const;
    void PollEvents();
    
    // Properties
    int32_t GetWidth() const;
    int32_t GetHeight() const;
    float GetAspectRatio() const;
    
    // Input
    bool IsKeyPressed(EKeyCode key) const;
    FVector2D GetMousePosition() const;
    
    // Vulkan surface
    VkSurfaceKHR CreateVulkanSurface(VkInstance instance);
};
```

### Vulkan Window

**File**: `GLFW3/Vulkan/VulkanWindow.h`

Extends GLFW3 window with Vulkan-specific functionality:
- Surface creation
- Swapchain recreation on resize
- Framebuffer scaling

### Window Configuration

```cpp
struct FWindowConfig {
    FString Title = "HLVM Engine";
    int32_t Width = 1920;
    int32_t Height = 1080;
    bool bFullscreen = false;
    bool bVSync = true;
    bool bResizable = true;
};
```

### Usage

```cpp
FWindowConfig config;
config.Title = "My Application";
config.Width = 1280;
config.Height = 720;

auto window = MakeShared<FGLFW3Window>(config);
window->Show();

while (!window->ShouldClose()) {
    window->PollEvents();
    // ... render ...
}
```

---

## RHI

**Location**: `/Engine/Source/Runtime/Renderer/RHI/`

### Overview

Rendering Hardware Interface (RHI) provides abstraction over graphics APIs. Currently supports Vulkan with dynamic loading.

### Architecture

```
RHI/
├── _Deprecated/          # Legacy RHI implementation (being phased out)
│   └── Vulkan/
│       ├── VulkanRHI.h
│       ├── VulkanDevice.h
│       ├── VulkanSwapChain.h
│       └── ...
└── Vulkan/               # New dynamic loading implementation
    └── VulkanLoader.h    # Vulkan function pointer loading
```

### Vulkan Loader

**File**: `Vulkan/VulkanLoader.h`

Dynamic Vulkan API loading without linking against Vulkan SDK:
```cpp
#define VK_NO_PROTOTYPES  // Defined by build system

class FVulkanLoader {
public:
    static void LoadGlobalCommands(VkInstance instance);
    static void LoadInstanceCommands(VkInstance instance);
    static void LoadDeviceCommands(VkDevice device);
    
    // Function pointers
    static PFN_vkCreateInstance CreateInstance;
    static PFN_vkDestroyInstance DestroyInstance;
    // ... all Vulkan commands
};
```

### Key Components (Deprecated but still used)

#### 1. VulkanRHI

Main RHI interface:
```cpp
class FVulkanRHI {
public:
    static FVulkanDevice* GetDevice();
    static VkInstance GetInstance();
    static VkPhysicalDevice GetPhysicalDevice();
};
```

#### 2. VulkanDevice

Device abstraction:
```cpp
class FVulkanDevice {
public:
    VkDevice GetDevice() const;
    VkQueue GetGraphicsQueue() const;
    VkQueue GetPresentQueue() const;
    uint32_t GetGraphicsQueueFamilyIndex() const;
};
```

#### 3. VulkanSwapChain

Swapchain management:
```cpp
class FVulkanSwapChain {
public:
    void Create(VkSurfaceKHR surface, int32_t width, int32_t height);
    void Destroy();
    void Present(VkSemaphore wait_semaphore);
    uint32_t AcquireNextImage(VkSemaphore signal_semaphore);
};
```

### Migration Status

The `_Deprecated` folder contains the legacy RHI implementation. New code should:
1. Use NVRHI (NVIDIA's RHI abstraction) where possible
2. Avoid direct Vulkan calls in application code
3. Use the new `VulkanLoader` for dynamic loading

### NVRHI Integration

The project uses a forked version of NVRHI for cross-vendor RHI abstraction:
```python
# In Runtime_cmake.py
nvrhi = FetchContent(
    git_repo_url='https://github.com/yhyu13/NVRHI.git',
    git_tag='2ac4b58c355f53827c2e1d0740849ce4d09d5dd6'
)
```

---

# Additional Components

## Parallelism

**Location**: `/Engine/Source/Common/Public/Core/Parallel/`

### Overview

Comprehensive parallelism primitives including locks, concurrent queues, and thread pools.

### Locks

**File**: `Lock.h`

#### 1. Atomic Flag Lock

```cpp
class FAtomicFlag {
    void Lock() const;
    void Unlock() const;
};

// Usage
FAtomicFlag lock;
{
    LOCK_GUARD(lock);  // RAII lock guard
    // Critical section
}
```

**Features**:
- Uses `std::atomic_flag` (lock-free)
- `_mm_pause` for spinning
- Deadlock timer in debug builds

#### 2. Recursive Lock

```cpp
class FRecursiveAtomicFlag {
    // Allows same thread to acquire lock multiple times
};

// Usage
LOCK_GUARD_RECURSIVE();
```

#### 3. Reader-Writer Lock

```cpp
class FRWLock {
    void LockRV(Group group);  // Read or Write
    void UnlockRV();
};

// Usage
LOCK_GUARD_RW(lock, FRWLock::Read);   // Multiple readers OK
LOCK_GUARD_RW(lock, FRWLock::Write);  // Exclusive writer
```

#### 4. Rival Lock

```cpp
class FRWRivalLock {
    // Two rival groups (e.g., Read/Write)
    // Only one group can hold lock at a time
    // Within group, access is shared
};
```

**Use Case**: ECS systems where reads are parallel but exclusive to writes.

### Concurrent Queues

**File**: `ConcurrentQueue.h`

#### SPSC/MPSC/MPMC Queues

```cpp
// SPSC: Single Producer Single Consumer
TConcurrentQueueSPSC<int> queue;
queue.Enqueue(42);
int value;
bool success = queue.Dequeue(value);

// MPMC: Multi Producer Multi Consumer
TConcurrentQueueMPMC<int> queue;
queue.Enqueue(42);  // Thread-safe
int value;
bool success = queue.Dequeue(value);  // Blocks if empty (with CV)
```

**Performance**: 1.5x faster than `boost::lockfree::queue` in benchmarks.

**Note**: Using `std::condition_variable` for blocking pop improves performance despite overhead.

### Thread Pool

**File**: `Async/WorkStealThreadPool.h`

```cpp
class FWorkStealThreadPool {
public:
    FWorkStealThreadPool(int32_t num_threads);
    
    template <typename F>
    std::future<decltype(F())> Submit(F&& func);
    
    void SetThreadAffinity(const TVector<int>& cpu_ids);
};

// Usage
FWorkStealThreadPool pool(8);
auto future = pool.Submit([]() {
    return expensive_computation();
});
auto result = future.get();
```

**Features**:
- Work stealing for load balancing
- `std::future` return type
- Thread affinity masks
- MPMC task queue with blocking

### Fiber Pool (Experimental)

**File**: `Async/WorkStealFiberPool.h`

```cpp
class FWorkStealFiberPool {
    // Uses boost::fibers for user-space threading
    // WARNING: Stability issues with work stealing
};
```

**Status**: Not recommended for production. Consider native `std::async` instead.

---

## Template Metaprogramming

**Location**: `/Engine/Source/Common/Public/Template/`

### Overview

Compile-time utilities for common tasks including obfuscation, type traits, and scoped helpers.

### String Obfuscation

**File**: `Obfuscate/MetaString.tpp`

```cpp
// Compile-time string obfuscation
constexpr auto obfuscated = MetaString::Obfuscate("sensitive_key");
const char* key = obfuscated.Decrypt();  // Decrypts at runtime
```

**Algorithm**: AdvoObfuscator-inspired with custom stack-free implementation for long strings.

**Use Cases**:
- RSA private keys
- API credentials
- Anti-tamper strings

### Compile-Time Regex

**File**: Uses `ctre` library

```cpp
static_assert(ctre::match<"^[0-9]+$">(input), "Must be numeric");
```

**Use**: Assertion checking in debug builds.

### Scoped Helpers

**File**: `GlobalTemplate.tpp`

```cpp
// Scoped variable with enter/exit actions
TScopedVariable<std::function<void()>, std::function<void()>> 
    scoped([](){ enter(); }, [](){ exit(); });

// Non-null pointer wrapper
TNonNullPtr<T> ptr = MakeNonNull(raw_ptr);
T* raw = ptr.Get();  // Never null
```

### Type Traits

```cpp
// Remove reference
typename TReferenceRemoved<T>::Type

// Remove optional
typename TOptionalRemoved<T>::Type

// Expression templates
template <typename Expr>
constexpr bool EvaluateExpression(Expr&& expr);
```

---

## Compression

**File**: `/Engine/Source/Common/Public/Core/Compress/Zstd.h`

### Overview

Zstandard compression wrapper for fast, high-ratio compression.

### Usage

```cpp
#include "Core/Compress/Zstd.h"

// Compress
FConstByteBuffer data = GetFileData();
TVector<TBYTE> compressed = FZstd::Compress(data, compress_level=1);

// Decompress
TVector<TBYTE> decompressed = FZstd::Decompress(compressed);
```

**Features**:
- Configurable compression level (default: 1 for speed)
- Automatic buffer shrinking
- Zero-copy decompression where possible

---

## Encryption

**File**: `/Engine/Source/Common/Public/Core/Encrypt/RSA.h`

### Overview

RSA encryption/decryption wrapper using Botan3 library.

### Usage

```cpp
#include "Core/Encrypt/RSA.h"

// Generate key (PKCS8, 256-bit, binary obfuscated)
auto [public_key, private_key] = FRSA::GenerateKeyPair(256);

// Encrypt (OAEP)
TVector<TBYTE> ciphertext = FRSA::EncryptOAEP(plaintext, public_key);

// Decrypt
TVector<TBYTE> plaintext = FRSA::DecryptOAEP(ciphertext, private_key);

// Sign (EMSA)
TVector<TBYTE> signature = FRSA::SignEMSA(message, private_key);

// Verify
bool valid = FRSA::VerifyEMSA(message, signature, public_key);
```

**Security Notes**:
- Private keys stored obfuscated in binary
- OAEP padding for encryption (resistant to chosen-ciphertext attacks)
- EMSA for signatures (deterministic)

---

## Debugging Utilities

**File**: `/Engine/Source/Common/Public/Platform/GenericPlatformDebuggerUtil.h`

### Features

#### 1. Debugger Detection

```cpp
if (IsDebuggerPresent()) {
    // Platform-specific: ptrace on Linux, WinAPI on Windows
}
```

#### 2. Stack Trace

```cpp
#include "Platform/GenericPlatformStackTrace.h"

PrintStackTrace(skip_frames=2);  // Skip current function frames
```

**Backend**: backward-cpp library with symbolic resolution.

#### 3. Assertion System

**File**: `Core/Assert.h`

```cpp
// Development mode only
HLVM_ASSERT(x > 0);
HLVM_ASSERT_F(x > 0, TXT("Expected positive, got {}"), x);

// Always evaluated
HLVM_ENSURE(x > 0);
HLVM_ENSURE_F(x > 0, TXT("Expected positive, got {}"), x);
```

**Features**:
- No-inline assertion functions (avoid code bloat)
- Stack trace on failure
- Custom allocator for assertion messages (stack allocator to avoid allocation in error paths)
- Atomic lock for thread-safe assertion handling

---

## Exception Handling

**File**: `/Engine/Source/Common/Public/Core/Assert.h`

### Overview

Custom exception system without C++ exceptions (disabled for performance).

### Implementation

```cpp
[[noreturn]] void hlvm_internal_assert(
    const TCHAR* Expression,
    const FString* Message,
    const TCHAR* File,
    int Line
);
```

**Flow**:
1. Assertion fails
2. Swap to stack allocator (avoid dynamic allocation)
3. Format message with file/line
4. Print stack trace
5. Abort program

### Configuration

```cpp
#define HLVM_ASSERT_EVEN_IN_RELEASE 0  // Enable asserts in release
#define HLVM_ASSERT_ALWAYS_EVALUATE_EXPRESSION 0  // Always evaluate expression
```

**Default Behavior**:
- Debug: Assertions enabled, expression evaluated
- Release: Assertions compiled out, expression not evaluated (unless configured)

---

## Hashing

**File**: `/Engine/Source/Common/Public/Utility/Hash.h`

### Overview

Boost-based hashing utilities for common algorithms.

### Supported Algorithms

```cpp
// MD5
FString md5_hex = FHash::MD5Hex(data);
TArray<TBYTE> md5_bin = FHash::MD5Binary(data);

// SHA1
FString sha1_hex = FHash::SHA1Hex(data);
TArray<TBYTE> sha1_bin = FHash::SHA1Binary(data);
```

**Features**:
- Hex string conversion
- Binary digest output
- Incremental hashing for large data

---

# More?

## Build System Summary

1. **PyCMake**: Python wrapper for CMake generation
2. **vcpkg**: Dependency management (forked version)
3. **Build.sh**: Comprehensive build/test/profiling script
4. **CTest**: Unit testing framework

## Code Organization

1. **Public/Private**: Strict header/source separation
2. **Common Module**: Foundational utilities
3. **Runtime Module**: Engine subsystems

## Core Systems

1. **Memory**: Pluggable allocator with mimalloc, stack, VM allocators
2. **String**: FString with UTF-8 support
3. **Logging**: UE5-style macros with spdlog backend
4. **CVar**: Console variables with INI persistence
5. **Platform**: Cross-platform abstraction (Linux/Windows)
6. **File System**: Boost backend + packed container format

## Advanced Features

1. **Parallelism**: Locks, concurrent queues, work-stealing thread pool
2. **Template Meta**: Obfuscation, type traits, scoped helpers
3. **Compression**: Zstandard wrapper
4. **Encryption**: RSA OAEP/EMSA with Botan3
5. **Debugging**: Assertion system, stack traces, debugger detection

## Future Work

- [ ] VMMallocator completion (lock-free, thread-local)
- [ ] FName/FText constant string pooling
- [ ] NVRHI migration (deprecate legacy RHI)
- [ ] Fiber pool stability improvements
- [ ] CI/CD pipeline (GitHub Actions)
- [ ] Windows build support
